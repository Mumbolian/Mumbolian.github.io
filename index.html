<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>T Man's Snooze Schedule</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color-scheme: dark;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, #1f2937 0, #020617 55%, #020617 100%);
      color: #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }
    main {
      width: 100%;
      max-width: 720px;
      background: rgba(15, 23, 42, 0.96);
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      box-shadow: 0 24px 60px rgba(0, 0, 0, 0.6);
      padding: 20px 18px 18px;
    }
    @media (min-width: 640px) {
      main {
        padding: 24px 26px 22px;
      }
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 16px;
      margin-bottom: 18px;
    }
    .title-block h1 {
      margin: 0 0 4px;
      font-size: 1.5rem;
    }
    .title-block p {
      margin: 0;
      font-size: 0.86rem;
      color: #9ca3af;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      background: rgba(34, 197, 94, 0.12);
      color: #bbf7d0;
      font-size: 0.7rem;
      white-space: nowrap;
    }
    .dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 8px #22c55e;
    }

    .layout {
      display: grid;
      grid-template-columns: 1.05fr 1.1fr;
      gap: 18px;
    }
    @media (max-width: 640px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: radial-gradient(circle at top left, rgba(30, 64, 175, 0.35), rgba(15, 23, 42, 0.96) 55%);
      border-radius: 14px;
      padding: 14px 14px 12px;
      border: 1px solid rgba(51, 65, 85, 0.9);
    }
    .card.secondary {
      background: radial-gradient(circle at top right, rgba(22, 163, 74, 0.32), rgba(15, 23, 42, 0.96) 55%);
    }
    .card h2 {
      margin: 0 0 10px;
      font-size: 0.95rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .card h2 span {
      font-weight: 500;
      font-size: 0.8rem;
      color: #9ca3af;
    }

    .form-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px 12px;
      margin-bottom: 8px;
    }
    .form-row {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-bottom: 8px;
    }
    label {
      font-size: 0.78rem;
      color: #9ca3af;
    }
    input[type="time"],
    input[type="number"] {
      width: 100%;
      padding: 6px 8px;
      border-radius: 9px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.98);
      color: #e5e7eb;
      font-size: 0.8rem;
      outline: none;
    }
    input[type="time"]:focus,
    input[type="number"]:focus {
      border-color: #60a5fa;
      box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.45);
    }
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    input[type="number"] {
      -moz-appearance: textfield;
    }

    .inline {
      display: flex;
      align-items: center;
      gap: 7px;
      font-size: 0.76rem;
      color: #9ca3af;
      margin-bottom: 4px;
    }
    .inline input[type="checkbox"] {
      width: 14px;
      height: 14px;
      accent-color: #22c55e;
    }

    .buttons-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 4px;
    }
    button {
      border-radius: 999px;
      border: 1px solid rgba(75, 85, 99, 0.9);
      background: rgba(15, 23, 42, 0.98);
      color: #e5e7eb;
      font-size: 0.75rem;
      padding: 5px 9px;
      cursor: pointer;
    }
    button:hover {
      border-color: #60a5fa;
    }
    button.primary {
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: #022c22;
      border-color: transparent;
      font-weight: 600;
    }
    button.primary:hover {
      filter: brightness(1.05);
    }

    .nap-rows {
      margin-top: 4px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .nap-row {
      display: grid;
      grid-template-columns: minmax(85px, 1fr) minmax(130px, 1fr) auto;
      align-items: center;
      gap: 10px;
      font-size: 0.8rem;
    }

    .nap-row span.label {
      color: #d1d5db;
      min-width: 0;
      white-space: nowrap;
    }

    .nap-row .unit {
      font-size: 0.72rem;
      color: #6b7280;
      margin-left: 2px;
    }

    .schedule-list {
      margin: 6px 0 4px;
      padding: 0;
      list-style: none;
      font-size: 0.8rem;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .schedule-list li {
      padding: 6px 8px;
      border-radius: 9px;
      background: rgba(15, 23, 42, 0.96);
      border: 1px solid rgba(55, 65, 81, 0.9);
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 8px;
    }
    .time {
      font-variant-numeric: tabular-nums;
    }
    .badge {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(37, 99, 235, 0.15);
      color: #bfdbfe;
      white-space: nowrap;
    }
    .badge.wake {
      background: rgba(234, 179, 8, 0.14);
      color: #facc15;
    }
    .badge.bed {
      background: rgba(34, 197, 94, 0.16);
      color: #bbf7d0;
    }
    .subtext {
      font-size: 0.72rem;
      color: #9ca3af;
      margin-top: 4px;
    }
    .warning {
      margin-top: 4px;
      font-size: 0.72rem;
      color: #fecaca;
      background: rgba(248, 113, 113, 0.12);
      border-radius: 8px;
      padding: 4px 6px;
      border: 1px solid rgba(248, 113, 113, 0.35);
    }
    .footer {
      margin-top: 10px;
      font-size: 0.7rem;
      color: #6b7280;
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }
    code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.75rem;
      background: rgba(15, 23, 42, 0.9);
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid rgba(55, 65, 81, 0.8);
    }

    @media (max-width: 420px) {
      .nap-row {
        grid-template-columns: 1fr 1fr auto;
      }
    }
  </style>
</head>
<body>
<main>
  <header>
    <div class="title-block">
      <h1>T Man's Snooze Schedule</h1>
    </div>
    <div class="pill">
      <span class="dot"></span>
      <span>Local-only • No login</span>
    </div>
  </header>

  <div class="layout">
    <!-- Controls -->
    <section class="card">
      <h2>
        Inputs
        <span>Schedule updates instantly as you tweak</span>
      </h2>

      <div class="form-grid">
        <div class="form-row">
          <label for="wakeTime">Wake-up time</label>
          <input type="time" id="wakeTime" />
        </div>
        <div class="form-row">
          <label for="bedTime">Bedtime</label>
          <input type="time" id="bedTime" />
        </div>
      </div>

      <div class="inline">
        <input type="checkbox" id="useThreeNaps" />
        <label for="useThreeNaps">Prefer 3 naps (we'll drop to 2 if needed)</label>
      </div>

      <div class="nap-rows">
        <div class="nap-row">
          <span class="label">First wake window</span>
          <input type="number" id="firstWake" min="30" max="360" step="5" />
          <span class="unit">mins</span>
        </div>
        <div class="nap-row">
          <span class="label">Last wake window</span>
          <input type="number" id="lastWake" min="30" max="360" step="5" />
          <span class="unit">mins</span>
        </div>
        <div class="nap-row">
          <span class="label">Min wake window</span>
          <input type="number" id="minWake" min="30" max="360" step="5" />
          <span class="unit">mins</span>
        </div>
        <div class="nap-row">
          <span class="label">Max wake window</span>
          <input type="number" id="maxWake" min="30" max="360" step="5" />
          <span class="unit">mins</span>
        </div>
      </div>

      <hr style="border:none;border-top:1px solid rgba(51,65,85,0.9);margin:10px 0;" />

      <div class="nap-rows">
        <div class="nap-row">
          <span class="label">Nap 1 length</span>
          <input type="number" id="nap1Length" min="10" max="240" step="5" />
          <span class="unit">mins</span>
        </div>
        <div class="nap-row">
          <span class="label">Nap 2 length</span>
          <input type="number" id="nap2Length" min="10" max="240" step="5" />
          <span class="unit">mins</span>
        </div>
        <div class="nap-row" id="nap3Row">
          <span class="label">Nap 3 length</span>
          <input type="number" id="nap3Length" min="10" max="240" step="5" />
          <span class="unit">mins</span>
        </div>
      </div>

      <div class="buttons-row">
        <button type="button" id="resetDefaults">Reset to typical 7–8m pattern</button>
        <button type="button" id="copySchedule">Copy schedule text</button>
      </div>
      <p class="subtext">
        Bedtime and the last wake window are fixed. We fit the rest of the day in between using
        wake windows that grow from the first window up to the last, respecting your min/max limits.
      </p>
    </section>

    <!-- Output -->
    <section class="card secondary">
      <h2>
        Today’s schedule
        <span id="summaryLabel"></span>
      </h2>
      <ul class="schedule-list" id="scheduleList"></ul>
      <div id="wakeWindowsText" class="subtext"></div>
      <div id="bedtimeNote" class="subtext"></div>
      <div id="modeNote" class="subtext"></div>
      <div id="warningBox" class="warning" style="display:none;"></div>
    </section>
  </div>

  <div class="footer">
    <span>Settings are saved in this browser (localStorage).</span>
  </div>
</main>

<script>
  (function () {
    const STORAGE_KEY = "napPlannerSettings_v4";
    let isRecomputing = false; // Flag to prevent recursive recomputation

    const wakeInput = document.getElementById("wakeTime");
    const bedInput = document.getElementById("bedTime");
    const useThreeNapsInput = document.getElementById("useThreeNaps");

    const firstWakeInput = document.getElementById("firstWake");
    const lastWakeInput = document.getElementById("lastWake");
    const minWakeInput = document.getElementById("minWake");
    const maxWakeInput = document.getElementById("maxWake");

    const nap1Input = document.getElementById("nap1Length");
    const nap2Input = document.getElementById("nap2Length");
    const nap3Input = document.getElementById("nap3Length");
    const nap3Row = document.getElementById("nap3Row");

    const scheduleList = document.getElementById("scheduleList");
    const summaryLabel = document.getElementById("summaryLabel");
    const wakeWindowsText = document.getElementById("wakeWindowsText");
    const bedtimeNote = document.getElementById("bedtimeNote");
    const modeNote = document.getElementById("modeNote");
    const warningBox = document.getElementById("warningBox");
    const resetBtn = document.getElementById("resetDefaults");
    const copyBtn = document.getElementById("copySchedule");

    function toMinutes(timeStr) {
      if (!timeStr || !/^\d{2}:\d{2}$/.test(timeStr)) return null;
      const [h, m] = timeStr.split(":").map(Number);
      if (isNaN(h) || isNaN(m)) return null;
      return h * 60 + m;
    }

    function fromMinutes(totalMinutes) {
      totalMinutes = ((totalMinutes % (24 * 60)) + (24 * 60)) % (24 * 60);
      const h = Math.floor(totalMinutes / 60);
      const m = totalMinutes % 60;
      return `${String(h).padStart(2, "0")}:${String(m).padStart(2, "0")}`;
    }

    function formatDuration(mins) {
      if (mins <= 0) return "0 min";
      const h = Math.floor(mins / 60);
      const m = mins % 60;
      if (h && m) return `${h}h ${m}m`;
      if (h) return `${h}h`;
      return `${m}m`;
    }

    function loadSettings() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch {
        return null;
      }
    }

    function saveSettings() {
      const settings = {
        wakeTime: wakeInput.value || "",
        bedTime: bedInput.value || "",
        preferThree: !!useThreeNapsInput.checked,
        firstWake: Number(firstWakeInput.value) || 0,
        lastWake: Number(lastWakeInput.value) || 0,
        minWake: Number(minWakeInput.value) || 0,
        maxWake: Number(maxWakeInput.value) || 0,
        nap1: Number(nap1Input.value) || 0,
        nap2: Number(nap2Input.value) || 0,
        nap3: Number(nap3Input.value) || 0
      };
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
      } catch {
        // ignore
      }
    }

    function updateNap3Visibility(actualNapCount) {
      const preferThree = useThreeNapsInput.checked;
      const showThree = (actualNapCount || (preferThree ? 3 : 2)) === 3;
      nap3Row.style.display = showThree ? "grid" : "none";
    }

    function applyDefaults(forceThreeNaps = null) {
      wakeInput.value = "07:00";
      bedInput.value = "20:30";            // default fixed bedtime

      // If forceThreeNaps is specified, use that; otherwise keep current state
      if (forceThreeNaps !== null) {
        useThreeNapsInput.checked = forceThreeNaps;
      }

      firstWakeInput.value = 150;          // 2h30
      lastWakeInput.value = 210;           // 3h30
      minWakeInput.value = 150;            // 2h30 min
      maxWakeInput.value = 210;            // 3h30 max

      // Set nap length defaults based on number of naps
      const preferThree = useThreeNapsInput.checked;
      if (preferThree) {
        // 3 nap schedule defaults
        nap1Input.value = 30;   // 30 min
        nap2Input.value = 60;   // 1h
        nap3Input.value = 30;   // 30 min
      } else {
        // 2 nap schedule defaults
        nap1Input.value = 90;   // 1.5h
        nap2Input.value = 30;   // 30 min
        nap3Input.value = 30;   // not used for 2 naps
      }

      updateNap3Visibility(preferThree ? 3 : 2);
    }

    function initFromStorageOrDefaults() {
      const s = loadSettings();
      if (s) {
        if (s.wakeTime) wakeInput.value = s.wakeTime;
        if (s.bedTime) bedInput.value = s.bedTime;
        useThreeNapsInput.checked = !!s.preferThree;

        firstWakeInput.value = s.firstWake || 150;
        lastWakeInput.value = s.lastWake || 210;
        minWakeInput.value = s.minWake || 150;
        maxWakeInput.value = s.maxWake || 210;

        // Use appropriate defaults based on saved preference
        const preferThree = !!s.preferThree;
        nap1Input.value = s.nap1 || (preferThree ? 30 : 90);
        nap2Input.value = s.nap2 || (preferThree ? 60 : 30);
        nap3Input.value = s.nap3 || 30;
      } else {
        applyDefaults(true); // Force 3 naps for new users
      }
      updateNap3Visibility();
    }

    function tryBuildSchedule(napCount, params) {
      const {
        wakeMins,
        bedMins,
        lastWake,
        minWake,
        maxWake,
        napLengths
      } = params;

      const totalNapTime = napLengths.slice(0, napCount).reduce((a, b) => a + b, 0);
      const totalDay = bedMins - wakeMins;

      if (totalDay <= 0) {
        return { ok: false, reason: "Bedtime must be after wake time (same or next day)." };
      }

      const totalAwake = totalDay - totalNapTime;
      const remainingBeforeLast = totalAwake - lastWake;

      if (remainingBeforeLast < 0) {
        return { ok: false, reason: "Not enough time for naps + last wake window before bed." };
      }

      const nWindowsBeforeLast = napCount; // one before each nap
      if (nWindowsBeforeLast === 0) {
        return { ok: false, reason: "Need at least one nap." };
      }

      const minTotal = minWake * nWindowsBeforeLast;
      const maxTotal = maxWake * nWindowsBeforeLast;

      if (remainingBeforeLast < minTotal || remainingBeforeLast > maxTotal) {
        return {
          ok: false,
          reason: "Awake windows would have to go outside the min/max limits."
        };
      }

      // Build wake windows before naps, starting at min and adding to later windows first
      const wakeWindowsBefore = new Array(nWindowsBeforeLast).fill(minWake);
      let leftover = remainingBeforeLast - minTotal;

      for (let i = nWindowsBeforeLast - 1; i >= 0 && leftover > 0; i--) {
        const canAdd = maxWake - wakeWindowsBefore[i];
        const add = Math.min(canAdd, leftover);
        wakeWindowsBefore[i] += add;
        leftover -= add;
      }

      const wakeWindowsAll = [...wakeWindowsBefore, lastWake];

      // Build schedule items
      const items = [];
      const wakeWindowDurations = [];

      items.push({
        label: "Wake-up",
        timeRange: fromMinutes(wakeMins),
        badge: "Start of day",
        badgeClass: "wake"
      });

      let cursor = wakeMins;

      for (let i = 0; i < napCount; i++) {
        const ww = wakeWindowsBefore[i] || 0;
        const napLen = napLengths[i];

        cursor += ww;
        const napStart = cursor;
        const napEnd = napStart + napLen;
        wakeWindowDurations.push(ww);

        items.push({
          label: `Nap ${i + 1}`,
          timeRange: `${fromMinutes(napStart)} – ${fromMinutes(napEnd)}`,
          extra: `${napLen} min`,
          badge: "Nap",
          badgeClass: "",
          wakeWindow: ww  // Add wake window before this nap
        });

        cursor = napEnd;
      }

      // Final wake window to fixed bedtime
      const finalWakeWindow = lastWake;
      cursor += finalWakeWindow;
      wakeWindowDurations.push(finalWakeWindow);

      const resultingBedtimeMins = cursor; // should equal bedMins

      items.push({
        label: "Bedtime",
        timeRange: fromMinutes(resultingBedtimeMins),
        badge: "End of day",
        badgeClass: "bed",
        wakeWindow: finalWakeWindow  // Add wake window before bedtime
      });

      return {
        ok: true,
        items,
        wakeWindowsAll,
        wakeWindowDurations,
        totalNapTime,
        bedtimeMins: resultingBedtimeMins,
        napCountUsed: napCount
      };
    }

    function recomputeSchedule() {
      if (isRecomputing) return; // Prevent recursive calls
      isRecomputing = true;

      try {
        saveSettings();

        scheduleList.innerHTML = "";
        wakeWindowsText.textContent = "";
        summaryLabel.textContent = "";
        bedtimeNote.textContent = "";
        modeNote.textContent = "";
        warningBox.style.display = "none";

        const wakeMins = toMinutes(wakeInput.value);
        let bedMins = toMinutes(bedInput.value);

        if (wakeMins == null || bedMins == null) {
          warningBox.style.display = "block";
          warningBox.textContent = "Please set both wake-up time and bedtime.";
          return;
        }

        // Allow bedtime to roll onto next day if it's earlier than wake
        if (bedMins <= wakeMins) {
          bedMins += 24 * 60;
        }

        const minWake = Number(minWakeInput.value);
        const maxWake = Number(maxWakeInput.value);

        if (!minWake || !maxWake || minWake <= 0 || maxWake <= 0) {
          warningBox.style.display = "block";
          warningBox.textContent = "Please enter valid min and max wake window values (greater than 0).";
          return;
        }

        if (maxWake < minWake) {
          warningBox.style.display = "block";
          warningBox.textContent = "Max wake window must be greater than or equal to min wake window.";
          return;
        }

        let lastWake = Number(lastWakeInput.value);
        if (!lastWake || lastWake <= 0) {
          warningBox.style.display = "block";
          warningBox.textContent = "Please enter a valid last wake window value (greater than 0).";
          return;
        }
        // Clamp last wake to min/max, since it's also a wake window
        if (lastWake < minWake) lastWake = minWake;
        if (lastWake > maxWake) lastWake = maxWake;
        if (lastWake !== Number(lastWakeInput.value)) {
          lastWakeInput.value = lastWake;
        }

        const firstWake = Number(firstWakeInput.value);
        if (!firstWake || firstWake <= 0) {
          warningBox.style.display = "block";
          warningBox.textContent = "Please enter a valid first wake window value (greater than 0).";
          return;
        }
        // First wake isn't used directly in the math now, but kept as a "hint" parameter we could use later.

        const nap1Len = Number(nap1Input.value) || 0;
        const nap2Len = Number(nap2Input.value) || 0;
        const nap3Len = Number(nap3Input.value) || 0;
        const napLengths = [nap1Len, nap2Len, nap3Len];

        if (nap1Len <= 0 || nap2Len <= 0) {
          warningBox.style.display = "block";
          warningBox.textContent = "Nap 1 and Nap 2 lengths should be greater than 0 minutes.";
          return;
        }

        const preferThree = !!useThreeNapsInput.checked;
        let requestedNapCount = preferThree ? 3 : 2;

        const params = { wakeMins, bedMins, lastWake, minWake, maxWake, napLengths };

        // Try requested nap count
        const scheduleResult = requestedNapCount === 3
          ? tryBuildSchedule(3, params)
          : tryBuildSchedule(2, params);

        if (!scheduleResult || !scheduleResult.ok) {
          warningBox.style.display = "block";
          let errorMsg = "Could not create a valid schedule. ";

          if (scheduleResult && scheduleResult.reason) {
            errorMsg += scheduleResult.reason + " ";
          }

          // Provide specific guidance based on the error
          if (preferThree) {
            errorMsg += "Try: (1) Switch to 2 naps, or (2) ";
          } else {
            errorMsg += "Try: (1) ";
          }

          if (scheduleResult && scheduleResult.reason && scheduleResult.reason.includes("outside the min/max limits")) {
            errorMsg += "Increase max wake window, (2) Decrease min wake window, or (3) Reduce nap lengths.";
          } else if (scheduleResult && scheduleResult.reason && scheduleResult.reason.includes("Not enough time")) {
            errorMsg += "Reduce total nap time, (2) Move bedtime later, or (3) Reduce last wake window.";
          } else {
            errorMsg += "Adjust nap lengths, wake windows, or wake/bed times.";
          }

          warningBox.textContent = errorMsg;
          updateNap3Visibility(requestedNapCount);
          return;
        }

        const {
          items,
          wakeWindowDurations,
          totalNapTime,
          bedtimeMins,
          napCountUsed
        } = scheduleResult;

        updateNap3Visibility(napCountUsed);

        const scheduleTextLines = [];
        scheduleList.innerHTML = "";

        items.forEach((item) => {
          const li = document.createElement("li");
          const left = document.createElement("div");
          const right = document.createElement("div");

          left.innerHTML = `<strong>${item.label}</strong><br/><span class="time">${item.timeRange}</span>`;
          if (item.extra) {
            left.innerHTML += `<br/><span class="subtext">${item.extra}</span>`;
          }
          // Add wake window duration if present
          if (item.wakeWindow) {
            left.innerHTML += `<br/><span class="subtext" style="color: #facc15;">↑ ${formatDuration(item.wakeWindow)} awake</span>`;
          }

          if (item.badge) {
            right.innerHTML = `<span class="badge ${item.badgeClass || ""}">${item.badge}</span>`;
          }

          li.appendChild(left);
          li.appendChild(right);
          scheduleList.appendChild(li);

          if (item.label === "Wake-up" || item.label === "Bedtime") {
            scheduleTextLines.push(`${item.label}: ${item.timeRange}`);
          } else {
            scheduleTextLines.push(
                    `${item.label}: ${item.timeRange} (${item.extra || ""}`.replace(/\s+\(\)/, "")
            );
          }
        });

        // Wake window summary line
        const wwStrings = wakeWindowDurations.map((mins, idx) => {
          const label =
                  idx === 0
                          ? "Before nap 1"
                          : idx === wakeWindowDurations.length - 1
                                  ? "Before bed"
                                  : `Between naps ${idx} & ${idx + 1}`;
          return `${label}: ${formatDuration(mins)}`;
        });
        wakeWindowsText.textContent = wwStrings.join("  •  ");

        // Bedtime note (should match target)
        const totalNapHours = (totalNapTime / 60).toFixed(2);
        summaryLabel.textContent = `${napCountUsed} naps • ${totalNapHours}h total daytime sleep`;

        const originalTargetBed = toMinutes(bedInput.value);
        if (originalTargetBed != null) {
          // normalise original target to nearest instance to resulting bedtime
          let target = originalTargetBed;
          while (target < bedtimeMins - 12 * 60) target += 24 * 60;
          while (target > bedtimeMins + 12 * 60) target -= 24 * 60;
          const diff = bedtimeMins - target;
          const absDiff = Math.abs(diff);
          const sign = diff === 0 ? "" : diff > 0 ? "+" : "-";
          const diffStr = formatDuration(absDiff);
          bedtimeNote.textContent = `Bedtime is fixed at ${fromMinutes(
                  originalTargetBed
          )}. Schedule lands exactly there (${sign}${diffStr} difference after day normalisation).`;
        } else {
          bedtimeNote.textContent = `Resulting bedtime: ${fromMinutes(bedtimeMins)}`;
        }

        modeNote.textContent = ""; // Clear any previous mode notes

        copyBtn.dataset.scheduleText = scheduleTextLines.join("\n");
      } finally {
        isRecomputing = false; // Always reset the flag
      }
    }

    resetBtn.addEventListener("click", () => {
      applyDefaults();
      recomputeSchedule();
    });

    copyBtn.addEventListener("click", async () => {
      const text = copyBtn.dataset.scheduleText || "";
      if (!text) return;
      try {
        await navigator.clipboard.writeText(text);
        const prev = copyBtn.textContent;
        copyBtn.textContent = "Copied!";
        setTimeout(() => (copyBtn.textContent = prev), 900);
      } catch {
        const prev = copyBtn.textContent;
        copyBtn.textContent = "Copy failed";
        setTimeout(() => (copyBtn.textContent = prev), 900);
      }
    });

    // Special handler for prefer 3 naps checkbox - update defaults when toggled
    useThreeNapsInput.addEventListener("change", () => {
      const preferThree = useThreeNapsInput.checked;
      if (preferThree) {
        // Switching to 3 naps - apply 3-nap defaults
        nap1Input.value = 30;
        nap2Input.value = 60;
        nap3Input.value = 30;
      } else {
        // Switching to 2 naps - apply 2-nap defaults
        nap1Input.value = 90;
        nap2Input.value = 30;
      }
      recomputeSchedule();
    });

    [
      wakeInput,
      bedInput,
      firstWakeInput,
      lastWakeInput,
      minWakeInput,
      maxWakeInput,
      nap1Input,
      nap2Input,
      nap3Input
    ].forEach((el) => {
      el.addEventListener("input", recomputeSchedule);
    });

    initFromStorageOrDefaults();
    recomputeSchedule();
  })();
</script>
</body>
</html>
