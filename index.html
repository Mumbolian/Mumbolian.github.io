<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>T Man's Snooze Schedule</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color-scheme: dark;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(circle at top, #1f2937 0, #020617 55%, #020617 100%);
      color: #e5e7eb;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }
    main {
      width: 100%;
      max-width: 720px;
      background: rgba(15, 23, 42, 0.96);
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      box-shadow: 0 24px 60px rgba(0, 0, 0, 0.6);
      padding: 20px 18px 18px;
    }
    @media (min-width: 640px) {
      main {
        padding: 24px 26px 22px;
      }
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 16px;
      margin-bottom: 18px;
    }
    .title-block h1 {
      margin: 0 0 4px;
      font-size: 1.5rem;
    }
    .title-block p {
      margin: 0;
      font-size: 0.86rem;
      color: #9ca3af;
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      background: rgba(34, 197, 94, 0.12);
      color: #bbf7d0;
      font-size: 0.7rem;
      white-space: nowrap;
    }
    .dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: #22c55e;
      box-shadow: 0 0 8px #22c55e;
    }

    .layout {
      display: grid;
      grid-template-columns: 1.05fr 1.1fr;
      gap: 18px;
    }
    @media (max-width: 640px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: radial-gradient(circle at top left, rgba(30, 64, 175, 0.35), rgba(15, 23, 42, 0.96) 55%);
      border-radius: 14px;
      padding: 14px 14px 12px;
      border: 1px solid rgba(51, 65, 85, 0.9);
    }
    .card.secondary {
      background: radial-gradient(circle at top right, rgba(22, 163, 74, 0.32), rgba(15, 23, 42, 0.96) 55%);
    }
    .card h2 {
      margin: 0 0 10px;
      font-size: 0.95rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .card h2 span {
      font-weight: 500;
      font-size: 0.8rem;
      color: #9ca3af;
    }

    .form-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px 12px;
      margin-bottom: 8px;
    }
    .form-row {
      display: flex;
      flex-direction: column;
      gap: 4px;
      margin-bottom: 8px;
    }
    label {
      font-size: 0.78rem;
      color: #9ca3af;
    }
    input[type="time"],
    input[type="number"] {
      width: 100%;
      padding: 6px 8px;
      border-radius: 9px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.98);
      color: #e5e7eb;
      font-size: 0.8rem;
      outline: none;
    }
    input[type="time"]:focus,
    input[type="number"]:focus {
      border-color: #60a5fa;
      box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.45);
    }
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    input[type="number"] {
      -moz-appearance: textfield;
    }

    .inline {
      display: flex;
      align-items: center;
      gap: 7px;
      font-size: 0.76rem;
      color: #9ca3af;
      margin-bottom: 4px;
    }
    .inline input[type="checkbox"] {
      width: 14px;
      height: 14px;
      accent-color: #22c55e;
    }

    /* Nap preference toggle switch */
    .nap-toggle-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }
    .nap-toggle-label {
      font-size: 0.76rem;
      color: #9ca3af;
    }
    .nap-toggle-switch {
      position: relative;
      display: inline-flex;
      background: rgba(30, 41, 59, 0.8);
      border-radius: 999px;
      border: 1px solid rgba(75, 85, 99, 0.9);
      padding: 3px;
      cursor: pointer;
      user-select: none;
    }
    .nap-toggle-option {
      position: relative;
      z-index: 2;
      padding: 4px 16px;
      font-size: 0.75rem;
      font-weight: 500;
      color: #9ca3af;
      transition: color 0.2s ease;
      text-align: center;
      min-width: 65px;
    }
    .nap-toggle-option.active {
      color: #e5e7eb;
    }
    .nap-toggle-slider {
      position: absolute;
      top: 3px;
      left: 3px;
      height: calc(100% - 6px);
      width: calc(50% - 3px);
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.6), rgba(37, 99, 235, 0.8));
      border-radius: 999px;
      transition: transform 0.25s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }
    .nap-toggle-switch.three-naps .nap-toggle-slider {
      transform: translateX(100%);
    }
    /* Visual indicator when preference doesn't match actual schedule */
    .nap-toggle-switch.preference-mismatch {
      border-color: rgba(248, 113, 113, 0.7);
      box-shadow: 0 0 0 2px rgba(248, 113, 113, 0.15), 0 0 12px rgba(248, 113, 113, 0.3);
      animation: pulse-warning 2s ease-in-out infinite;
    }
    @keyframes pulse-warning {
      0%, 100% {
        box-shadow: 0 0 0 2px rgba(248, 113, 113, 0.15), 0 0 12px rgba(248, 113, 113, 0.3);
      }
      50% {
        box-shadow: 0 0 0 2px rgba(248, 113, 113, 0.25), 0 0 16px rgba(248, 113, 113, 0.4);
      }
    }

    .buttons-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 4px;
    }
    button {
      border-radius: 999px;
      border: 1px solid rgba(75, 85, 99, 0.9);
      background: rgba(15, 23, 42, 0.98);
      color: #e5e7eb;
      font-size: 0.75rem;
      padding: 5px 9px;
      cursor: pointer;
    }
    button:hover {
      border-color: #60a5fa;
    }
    button.primary {
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: #022c22;
      border-color: transparent;
      font-weight: 600;
    }
    button.primary:hover {
      filter: brightness(1.05);
    }
    button.collapse-toggle {
      width: 100%;
      text-align: left;
      margin: 8px 0 4px;
      padding: 6px 8px;
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.78rem;
      color: #9ca3af;
      background: rgba(15, 23, 42, 0.5);
    }
    button.collapse-toggle:hover {
      color: #e5e7eb;
      background: rgba(15, 23, 42, 0.8);
    }
    .toggle-arrow {
      display: inline-block;
      transition: transform 0.2s ease;
      font-size: 0.65rem;
    }
    .toggle-arrow.expanded {
      transform: rotate(90deg);
    }

    .nap-rows {
      margin-top: 4px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .nap-row {
      display: grid;
      grid-template-columns: minmax(85px, 1fr) minmax(130px, 1fr) auto;
      align-items: center;
      gap: 10px;
      font-size: 0.8rem;
    }

    .nap-row span.label {
      color: #d1d5db;
      min-width: 0;
      white-space: nowrap;
    }

    .nap-row .unit {
      font-size: 0.72rem;
      color: #6b7280;
      margin-left: 2px;
    }

    .schedule-list {
      margin: 6px 0 4px;
      padding: 0;
      list-style: none;
      font-size: 0.8rem;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .schedule-list li {
      padding: 6px 8px;
      border-radius: 9px;
      background: rgba(15, 23, 42, 0.96);
      border: 1px solid rgba(55, 65, 81, 0.9);
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 8px;
    }
    .time {
      font-variant-numeric: tabular-nums;
    }
    .badge {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(37, 99, 235, 0.15);
      color: #bfdbfe;
      white-space: nowrap;
    }
    .badge.wake {
      background: rgba(234, 179, 8, 0.14);
      color: #facc15;
    }
    .badge.bed {
      background: rgba(34, 197, 94, 0.16);
      color: #bbf7d0;
    }
    .badge.actual {
      background: rgba(34, 197, 94, 0.2);
      color: #bbf7d0;
      border: 1px solid rgba(34, 197, 94, 0.4);
    }
    .badge.planned {
      background: rgba(59, 130, 246, 0.15);
      color: #bfdbfe;
    }
    .subtext {
      font-size: 0.72rem;
      color: #9ca3af;
      margin-top: 4px;
    }
    .warning {
      margin-top: 4px;
      font-size: 0.72rem;
      color: #fecaca;
      background: rgba(248, 113, 113, 0.12);
      border-radius: 8px;
      padding: 4px 6px;
      border: 1px solid rgba(248, 113, 113, 0.35);
    }
    .footer {
      margin-top: 10px;
      font-size: 0.7rem;
      color: #6b7280;
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
    }
    code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 0.75rem;
      background: rgba(15, 23, 42, 0.9);
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid rgba(55, 65, 81, 0.8);
    }

    @media (max-width: 420px) {
      .nap-row {
        grid-template-columns: 1fr 1fr auto;
      }
    }

    /* Actual Naps Tracking Styles */
    .actual-naps-grid {
      display: flex;
      flex-direction: column;
      gap: 14px;
      margin-bottom: 12px;
    }
    .actual-nap-row {
      background: rgba(15, 23, 42, 0.96);
      border: 1px solid rgba(55, 65, 81, 0.9);
      border-radius: 10px;
      padding: 10px 12px;
      transition: all 0.2s ease;
    }
    .actual-nap-row.has-data {
      border-color: rgba(34, 197, 94, 0.5);
      background: rgba(34, 197, 94, 0.05);
    }
    .nap-label-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .nap-label {
      font-size: 0.85rem;
      font-weight: 600;
      color: #d1d5db;
    }
    .clear-nap-btn {
      background: transparent;
      border: none;
      color: #9ca3af;
      font-size: 0.9rem;
      padding: 2px 6px;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s ease;
      line-height: 1;
    }
    .clear-nap-btn:hover {
      background: rgba(239, 68, 68, 0.15);
      color: #fca5a5;
    }
    .time-inputs-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-bottom: 8px;
    }
    .time-input-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .time-input-group label {
      font-size: 0.72rem;
      color: #9ca3af;
    }
    .actual-nap-input {
      width: 100%;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      background: rgba(15, 23, 42, 0.98);
      color: #e5e7eb;
      font-size: 0.8rem;
      outline: none;
      transition: all 0.2s ease;
    }
    .actual-nap-input:focus {
      border-color: #60a5fa;
      box-shadow: 0 0 0 1px rgba(37, 99, 235, 0.45);
    }
    .actual-nap-input.has-value {
      border-color: rgba(34, 197, 94, 0.5);
      background: rgba(34, 197, 94, 0.05);
    }
    .nap-insights {
      font-size: 0.72rem;
      color: #9ca3af;
      padding: 6px 8px;
      background: rgba(30, 41, 59, 0.5);
      border-radius: 6px;
      line-height: 1.4;
      display: none;
    }
    .nap-insights.visible {
      display: block;
    }
    .nap-insights .insight-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 2px 0;
    }
    .nap-insights .insight-label {
      color: #9ca3af;
    }
    .nap-insights .insight-value {
      color: #e5e7eb;
      font-weight: 500;
    }
    .nap-insights .insight-value.positive {
      color: #bbf7d0;
    }
    .nap-insights .insight-value.negative {
      color: #fca5a5;
    }
    .overall-insights {
      background: rgba(30, 64, 175, 0.12);
      border: 1px solid rgba(59, 130, 246, 0.3);
      border-radius: 8px;
      padding: 8px 10px;
      font-size: 0.75rem;
      color: #bfdbfe;
      line-height: 1.5;
      margin-bottom: 10px;
      display: none;
    }
    .overall-insights.visible {
      display: block;
    }

    /* Modal Styles */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }
    .modal-backdrop {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.75);
      backdrop-filter: blur(4px);
    }
    .modal-content {
      position: relative;
      background: rgba(15, 23, 42, 0.98);
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.3);
      box-shadow: 0 24px 60px rgba(0, 0, 0, 0.8);
      width: 100%;
      max-width: 500px;
      max-height: 90vh;
      overflow-y: auto;
      z-index: 1001;
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 18px 20px 14px;
      border-bottom: 1px solid rgba(51, 65, 85, 0.9);
    }
    .modal-header h3 {
      margin: 0;
      font-size: 1.2rem;
      font-weight: 600;
    }
    .close-btn {
      background: transparent;
      border: none;
      color: #9ca3af;
      font-size: 1.8rem;
      line-height: 1;
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
    }
    .close-btn:hover {
      background: rgba(55, 65, 81, 0.5);
      color: #e5e7eb;
    }
    .modal-body {
      padding: 18px 20px;
    }
    .constraint-section {
      margin-bottom: 4px;
    }
    .constraint-section h4 {
      margin: 0 0 6px;
      font-size: 0.95rem;
      font-weight: 600;
      color: #e5e7eb;
    }
    .constraint-description {
      margin: 0 0 10px;
      font-size: 0.78rem;
      color: #9ca3af;
    }
    .clear-btn {
      font-size: 0.72rem;
      padding: 4px 8px;
      margin-top: 6px;
      background: rgba(239, 68, 68, 0.15);
      color: #fca5a5;
      border-color: rgba(239, 68, 68, 0.3);
    }
    .clear-btn:hover {
      background: rgba(239, 68, 68, 0.25);
      border-color: rgba(239, 68, 68, 0.5);
    }
    .modal-footer {
      padding: 14px 20px 18px;
      border-top: 1px solid rgba(51, 65, 85, 0.9);
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }
    .modal-footer button {
      padding: 8px 16px;
      font-size: 0.85rem;
    }

    @media (max-width: 640px) {
      .modal {
        padding: 0;
      }
      .modal-content {
        max-width: 100%;
        max-height: 100%;
        border-radius: 0;
      }
    }
  </style>
</head>
<body>
<main>
  <header>
    <div class="title-block">
      <h1>T Man's Snooze Schedule</h1>
    </div>
    <div class="pill">
      <span class="dot"></span>
      <span>Local-only â€¢ No login</span>
    </div>
  </header>

  <div class="layout">
    <!-- Controls -->
    <section class="card">
      <h2>
        Planned Schedule Inputs
        <span>Schedule updates instantly as you tweak</span>
      </h2>

      <div class="form-grid">
        <div class="form-row">
          <label for="wakeTime">Wake-up time</label>
          <input type="time" id="wakeTime" />
        </div>
        <div class="form-row">
          <label for="bedTime">Bedtime</label>
          <input type="time" id="bedTime" />
        </div>
      </div>

      <div class="nap-toggle-container">
        <span class="nap-toggle-label">Nap preference:</span>
        <div class="nap-toggle-switch" id="napToggleSwitch">
          <div class="nap-toggle-slider"></div>
          <div class="nap-toggle-option" data-value="2">2 naps</div>
          <div class="nap-toggle-option active" data-value="3">3 naps</div>
        </div>
        <!-- Hidden checkbox to maintain compatibility with existing JS -->
        <input type="checkbox" id="useThreeNaps" style="display: none;" />
      </div>

      <button type="button" id="toggleWakeWindows" class="collapse-toggle">
        <span class="toggle-arrow">â–¶</span>
        Wake window settings
      </button>

      <div class="nap-rows" id="wakeWindowsSection" style="display: none;">
        <div class="nap-row">
          <span class="label">Last wake window</span>
          <input type="number" id="lastWake" min="30" max="360" step="5" />
          <span class="unit">mins</span>
        </div>
        <div class="nap-row">
          <span class="label">Min wake window</span>
          <input type="number" id="minWake" min="30" max="360" step="5" />
          <span class="unit">mins</span>
        </div>
        <div class="nap-row">
          <span class="label">Max wake window</span>
          <input type="number" id="maxWake" min="30" max="360" step="5" />
          <span class="unit">mins</span>
        </div>
      </div>

      <hr style="border:none;border-top:1px solid rgba(51,65,85,0.9);margin:10px 0;" />

      <div class="nap-rows">
        <div class="nap-row">
          <span class="label">Nap 1 length</span>
          <input type="number" id="nap1Length" min="10" max="240" step="5" />
          <span class="unit">mins</span>
        </div>
        <div class="nap-row">
          <span class="label">Nap 2 length</span>
          <input type="number" id="nap2Length" min="10" max="240" step="5" />
          <span class="unit">mins</span>
        </div>
        <div class="nap-row" id="nap3Row">
          <span class="label">Nap 3 length</span>
          <input type="number" id="nap3Length" min="10" max="240" step="5" />
          <span class="unit">mins</span>
        </div>
      </div>

      <div class="buttons-row">
        <button type="button" id="resetDefaults">Reset to defaults</button>
        <button type="button" id="copySchedule">Copy schedule text</button>
        <button type="button" id="openActualNaps">ðŸ“Š Track Actual Naps</button>
        <button type="button" id="openConstraints">ðŸŽ¯ Schedule Constraints</button>
      </div>
      <p class="subtext">
        Bedtime and the last wake window are fixed. We fit the rest of the day in between using
        wake windows that grow from the first window up to the last, respecting your min/max limits.
      </p>
    </section>

    <!-- Output -->
    <section class="card secondary">
      <h2>
        Todayâ€™s schedule
        <span id="summaryLabel"></span>
      </h2>
      <ul class="schedule-list" id="scheduleList"></ul>
      <div id="wakeWindowsText" class="subtext"></div>
      <div id="bedtimeNote" class="subtext"></div>
      <div id="modeNote" class="subtext"></div>
      <div id="warningBox" class="warning" style="display:none;"></div>
    </section>
  </div>

  <!-- Constraints Modal -->
  <div id="constraintsModal" class="modal" style="display: none;">
    <div class="modal-backdrop"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h3>Schedule Constraints</h3>
        <button type="button" id="closeModal" class="close-btn">&times;</button>
      </div>

      <div class="modal-body">
        <div class="constraint-section">
          <h4>Need baby awake by a certain time?</h4>
          <p class="constraint-description">For leaving the house, appointments, etc.</p>
          <div class="form-row">
            <label for="mustBeAwakeBy">Baby must be awake by</label>
            <input type="time" id="mustBeAwakeBy" />
          </div>
          <button type="button" id="clearAwakeBy" class="clear-btn">Clear</button>
        </div>

        <hr style="border:none;border-top:1px solid rgba(51,65,85,0.9);margin:14px 0;" />

        <div class="constraint-section">
          <h4>Need baby asleep during a time window?</h4>
          <p class="constraint-description">For calls, quiet time, sibling pickup, etc.</p>
          <div class="form-grid">
            <div class="form-row">
              <label for="sleepWindowStart">From</label>
              <input type="time" id="sleepWindowStart" />
            </div>
            <div class="form-row">
              <label for="sleepWindowEnd">Until</label>
              <input type="time" id="sleepWindowEnd" />
            </div>
          </div>
          <button type="button" id="clearSleepWindow" class="clear-btn">Clear</button>
        </div>
      </div>

      <div class="modal-footer">
        <button type="button" id="applyConstraints" class="primary">Apply Constraints</button>
      </div>
    </div>
  </div>

  <!-- Actual Naps Tracking Modal -->
  <div id="actualNapsModal" class="modal" style="display: none;">
    <div class="modal-backdrop"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h3>Track Today's Naps</h3>
        <button type="button" id="closeActualNapsModal" class="close-btn">&times;</button>
      </div>

      <div class="modal-body">
        <p class="constraint-description" style="margin-bottom: 14px;">
          Enter actual nap times to analyze wake windows and compare to your plan. Data auto-resets at midnight UTC.
        </p>

        <div class="actual-naps-grid" id="actualNapsGrid">
          <!-- Nap 1 -->
          <div class="actual-nap-row" id="actualNap1Row">
            <div class="nap-label-row">
              <span class="nap-label">Nap 1</span>
              <button type="button" class="clear-nap-btn" data-nap="1" title="Clear nap 1">âœ•</button>
            </div>
            <div class="time-inputs-row">
              <div class="time-input-group">
                <label for="actualNap1Start">Start</label>
                <input type="time" id="actualNap1Start" class="actual-nap-input" />
              </div>
              <div class="time-input-group">
                <label for="actualNap1End">End</label>
                <input type="time" id="actualNap1End" class="actual-nap-input" />
              </div>
            </div>
            <div class="nap-insights" id="nap1Insights"></div>
          </div>

          <!-- Nap 2 -->
          <div class="actual-nap-row" id="actualNap2Row">
            <div class="nap-label-row">
              <span class="nap-label">Nap 2</span>
              <button type="button" class="clear-nap-btn" data-nap="2" title="Clear nap 2">âœ•</button>
            </div>
            <div class="time-inputs-row">
              <div class="time-input-group">
                <label for="actualNap2Start">Start</label>
                <input type="time" id="actualNap2Start" class="actual-nap-input" />
              </div>
              <div class="time-input-group">
                <label for="actualNap2End">End</label>
                <input type="time" id="actualNap2End" class="actual-nap-input" />
              </div>
            </div>
            <div class="nap-insights" id="nap2Insights"></div>
          </div>

          <!-- Nap 3 -->
          <div class="actual-nap-row" id="actualNap3Row">
            <div class="nap-label-row">
              <span class="nap-label">Nap 3</span>
              <button type="button" class="clear-nap-btn" data-nap="3" title="Clear nap 3">âœ•</button>
            </div>
            <div class="time-inputs-row">
              <div class="time-input-group">
                <label for="actualNap3Start">Start</label>
                <input type="time" id="actualNap3Start" class="actual-nap-input" />
              </div>
              <div class="time-input-group">
                <label for="actualNap3End">End</label>
                <input type="time" id="actualNap3End" class="actual-nap-input" />
              </div>
            </div>
            <div class="nap-insights" id="nap3Insights"></div>
          </div>
        </div>

        <div class="overall-insights" id="overallInsights"></div>
      </div>

      <div class="modal-footer">
        <button type="button" id="clearAllActuals">Clear all</button>
        <button type="button" id="useActualDurations" class="primary">Apply durations to plan</button>
      </div>
    </div>
  </div>

  <div class="footer">
    <span>Settings are saved in this browser (localStorage).</span>
    <span id="versionDisplay" style="margin-left: 10px; opacity: 0.7;"></span>
  </div>
</main>

<script>
  (function () {
    const APP_VERSION = "1.5.0"; // Semantic versioning: MAJOR.MINOR.PATCH
    const STORAGE_KEY = "napPlannerSettings_v5";
    const ACTUAL_NAPS_KEY = "napPlannerActuals_v1";
    const LAST_RESET_KEY = "napPlannerLastReset";
    let isRecomputing = false; // Flag to prevent recursive recomputation

    const wakeInput = document.getElementById("wakeTime");
    const bedInput = document.getElementById("bedTime");
    const useThreeNapsInput = document.getElementById("useThreeNaps");
    const napToggleSwitch = document.getElementById("napToggleSwitch");

    // Actual naps tracking elements
    const actualNap1Start = document.getElementById("actualNap1Start");
    const actualNap1End = document.getElementById("actualNap1End");
    const actualNap2Start = document.getElementById("actualNap2Start");
    const actualNap2End = document.getElementById("actualNap2End");
    const actualNap3Start = document.getElementById("actualNap3Start");
    const actualNap3End = document.getElementById("actualNap3End");
    const actualNap1Row = document.getElementById("actualNap1Row");
    const actualNap2Row = document.getElementById("actualNap2Row");
    const actualNap3Row = document.getElementById("actualNap3Row");
    const nap1Insights = document.getElementById("nap1Insights");
    const nap2Insights = document.getElementById("nap2Insights");
    const nap3Insights = document.getElementById("nap3Insights");
    const overallInsights = document.getElementById("overallInsights");
    const clearAllActualsBtn = document.getElementById("clearAllActuals");
    const useActualDurationsBtn = document.getElementById("useActualDurations");

    const lastWakeInput = document.getElementById("lastWake");
    const minWakeInput = document.getElementById("minWake");
    const maxWakeInput = document.getElementById("maxWake");

    const nap1Input = document.getElementById("nap1Length");
    const nap2Input = document.getElementById("nap2Length");
    const nap3Input = document.getElementById("nap3Length");
    const nap3Row = document.getElementById("nap3Row");

    const scheduleList = document.getElementById("scheduleList");
    const summaryLabel = document.getElementById("summaryLabel");
    const wakeWindowsText = document.getElementById("wakeWindowsText");
    const bedtimeNote = document.getElementById("bedtimeNote");
    const modeNote = document.getElementById("modeNote");
    const warningBox = document.getElementById("warningBox");
    const resetBtn = document.getElementById("resetDefaults");
    const copyBtn = document.getElementById("copySchedule");

    const toggleWakeWindowsBtn = document.getElementById("toggleWakeWindows");
    const wakeWindowsSection = document.getElementById("wakeWindowsSection");

    // Constraints modal elements
    const openConstraintsBtn = document.getElementById("openConstraints");
    const constraintsModal = document.getElementById("constraintsModal");
    const closeModalBtn = document.getElementById("closeModal");
    const applyConstraintsBtn = document.getElementById("applyConstraints");
    const modalBackdrop = constraintsModal.querySelector(".modal-backdrop");

    // Actual naps modal elements
    const openActualNapsBtn = document.getElementById("openActualNaps");
    const actualNapsModal = document.getElementById("actualNapsModal");
    const closeActualNapsModalBtn = document.getElementById("closeActualNapsModal");
    const actualNapsModalBackdrop = actualNapsModal.querySelector(".modal-backdrop");

    const mustBeAwakeByInput = document.getElementById("mustBeAwakeBy");
    const sleepWindowStartInput = document.getElementById("sleepWindowStart");
    const sleepWindowEndInput = document.getElementById("sleepWindowEnd");
    const clearAwakeByBtn = document.getElementById("clearAwakeBy");
    const clearSleepWindowBtn = document.getElementById("clearSleepWindow");

    // Toggle wake windows section
    toggleWakeWindowsBtn.addEventListener("click", () => {
      const isHidden = wakeWindowsSection.style.display === "none";
      wakeWindowsSection.style.display = isHidden ? "flex" : "none";
      const arrow = toggleWakeWindowsBtn.querySelector(".toggle-arrow");
      if (isHidden) {
        arrow.classList.add("expanded");
      } else {
        arrow.classList.remove("expanded");
      }
    });

    // Update constraints button to show active state
    function updateConstraintsButton() {
      const hasAwakeBy = !!mustBeAwakeByInput.value;
      const hasSleepWindow = !!(sleepWindowStartInput.value && sleepWindowEndInput.value);
      const constraintsActive = hasAwakeBy || hasSleepWindow;

      if (constraintsActive) {
        const count = (hasAwakeBy ? 1 : 0) + (hasSleepWindow ? 1 : 0);
        openConstraintsBtn.textContent = `ðŸŽ¯ Constraints (${count})`;
        openConstraintsBtn.style.background = "rgba(34, 197, 94, 0.15)";
        openConstraintsBtn.style.borderColor = "rgba(34, 197, 94, 0.5)";
        openConstraintsBtn.style.color = "#bbf7d0";
      } else {
        openConstraintsBtn.textContent = "ðŸŽ¯ Schedule Constraints";
        openConstraintsBtn.style.background = "";
        openConstraintsBtn.style.borderColor = "";
        openConstraintsBtn.style.color = "";
      }
    }

    // Update actual naps button to show active state
    function updateActualNapsButton() {
      let napCount = 0;
      if (actualNap1Start.value && actualNap1End.value) napCount++;
      if (actualNap2Start.value && actualNap2End.value) napCount++;
      if (actualNap3Start.value && actualNap3End.value) napCount++;

      if (napCount > 0) {
        openActualNapsBtn.textContent = `ðŸ“Š Tracked Naps (${napCount})`;
        openActualNapsBtn.style.background = "rgba(34, 197, 94, 0.15)";
        openActualNapsBtn.style.borderColor = "rgba(34, 197, 94, 0.5)";
        openActualNapsBtn.style.color = "#bbf7d0";
      } else {
        openActualNapsBtn.textContent = "ðŸ“Š Track Actual Naps";
        openActualNapsBtn.style.background = "";
        openActualNapsBtn.style.borderColor = "";
        openActualNapsBtn.style.color = "";
      }
    }

    // Modal open/close handlers
    function openModal() {
      constraintsModal.style.display = "flex";
      document.body.style.overflow = "hidden";
    }

    function closeModal() {
      constraintsModal.style.display = "none";
      document.body.style.overflow = "";
      updateConstraintsButton();
    }

    openConstraintsBtn.addEventListener("click", openModal);
    closeModalBtn.addEventListener("click", closeModal);
    modalBackdrop.addEventListener("click", closeModal);

    // Actual naps modal open/close
    function openActualNapsModal() {
      actualNapsModal.style.display = "flex";
      document.body.style.overflow = "hidden";
    }

    function closeActualNapsModal() {
      actualNapsModal.style.display = "none";
      document.body.style.overflow = "";
      updateActualNapsButton();
    }

    openActualNapsBtn.addEventListener("click", openActualNapsModal);
    closeActualNapsModalBtn.addEventListener("click", closeActualNapsModal);
    actualNapsModalBackdrop.addEventListener("click", closeActualNapsModal);

    // Clear constraint handlers
    clearAwakeByBtn.addEventListener("click", () => {
      mustBeAwakeByInput.value = "";
    });

    clearSleepWindowBtn.addEventListener("click", () => {
      sleepWindowStartInput.value = "";
      sleepWindowEndInput.value = "";
    });

    // Apply constraints and close modal
    applyConstraintsBtn.addEventListener("click", () => {
      closeModal();
      recomputeSchedule();
    });

    function toMinutes(timeStr) {
      if (!timeStr || !/^\d{2}:\d{2}$/.test(timeStr)) return null;
      const [h, m] = timeStr.split(":").map(Number);
      if (isNaN(h) || isNaN(m)) return null;
      return h * 60 + m;
    }

    function fromMinutes(totalMinutes) {
      totalMinutes = ((totalMinutes % (24 * 60)) + (24 * 60)) % (24 * 60);
      const h = Math.floor(totalMinutes / 60);
      const m = totalMinutes % 60;
      return `${String(h).padStart(2, "0")}:${String(m).padStart(2, "0")}`;
    }

    function formatDuration(mins) {
      if (mins <= 0) return "0 min";
      const h = Math.floor(mins / 60);
      const m = mins % 60;
      if (h && m) return `${h}h ${m}m`;
      if (h) return `${h}h`;
      return `${m}m`;
    }

    function loadSettings() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch {
        return null;
      }
    }

    // Check if we need to reset actual naps (new day in UTC)
    function checkMidnightReset() {
      const now = new Date();
      const today = now.toISOString().split('T')[0]; // Get UTC date in YYYY-MM-DD format
      const lastReset = localStorage.getItem(LAST_RESET_KEY);

      if (lastReset !== today) {
        // New day detected - clear actual naps
        clearAllActualNaps();
        localStorage.setItem(LAST_RESET_KEY, today);
      }
    }

    function saveSettings() {
      const settings = {
        wakeTime: wakeInput.value || "",
        bedTime: bedInput.value || "",
        preferThree: !!useThreeNapsInput.checked,
        lastWake: Number(lastWakeInput.value) || 0,
        minWake: Number(minWakeInput.value) || 0,
        maxWake: Number(maxWakeInput.value) || 0,
        nap1: Number(nap1Input.value) || 0,
        nap2: Number(nap2Input.value) || 0,
        nap3: Number(nap3Input.value) || 0,
        constraints: {
          mustBeAwakeBy: mustBeAwakeByInput.value || null,
          sleepWindow: {
            start: sleepWindowStartInput.value || null,
            end: sleepWindowEndInput.value || null
          }
        }
      };
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
      } catch {
        // ignore
      }
    }

    function saveActualNaps() {
      const actuals = {
        nap1: {
          start: actualNap1Start.value || null,
          end: actualNap1End.value || null
        },
        nap2: {
          start: actualNap2Start.value || null,
          end: actualNap2End.value || null
        },
        nap3: {
          start: actualNap3Start.value || null,
          end: actualNap3End.value || null
        }
      };
      try {
        localStorage.setItem(ACTUAL_NAPS_KEY, JSON.stringify(actuals));
      } catch {
        // ignore
      }
    }

    function loadActualNaps() {
      try {
        const raw = localStorage.getItem(ACTUAL_NAPS_KEY);
        if (!raw) return;
        const actuals = JSON.parse(raw);

        if (actuals.nap1) {
          actualNap1Start.value = actuals.nap1.start || "";
          actualNap1End.value = actuals.nap1.end || "";
        }
        if (actuals.nap2) {
          actualNap2Start.value = actuals.nap2.start || "";
          actualNap2End.value = actuals.nap2.end || "";
        }
        if (actuals.nap3) {
          actualNap3Start.value = actuals.nap3.start || "";
          actualNap3End.value = actuals.nap3.end || "";
        }
      } catch {
        // ignore
      }
    }

    function clearAllActualNaps() {
      actualNap1Start.value = "";
      actualNap1End.value = "";
      actualNap2Start.value = "";
      actualNap2End.value = "";
      actualNap3Start.value = "";
      actualNap3End.value = "";
      saveActualNaps();
      updateActualNapsInsights();
    }

    function clearSingleNap(napNum) {
      if (napNum === 1) {
        actualNap1Start.value = "";
        actualNap1End.value = "";
      } else if (napNum === 2) {
        actualNap2Start.value = "";
        actualNap2End.value = "";
      } else if (napNum === 3) {
        actualNap3Start.value = "";
        actualNap3End.value = "";
      }
      saveActualNaps();
      updateActualNapsInsights();
    }

    function updateActualNapsInsights() {
      const wakeMins = toMinutes(wakeInput.value);
      const nap1PlannedLen = Number(nap1Input.value) || 0;
      const nap2PlannedLen = Number(nap2Input.value) || 0;
      const nap3PlannedLen = Number(nap3Input.value) || 0;

      const naps = [
        {
          num: 1,
          startEl: actualNap1Start,
          endEl: actualNap1End,
          rowEl: actualNap1Row,
          insightsEl: nap1Insights,
          plannedDuration: nap1PlannedLen
        },
        {
          num: 2,
          startEl: actualNap2Start,
          endEl: actualNap2End,
          rowEl: actualNap2Row,
          insightsEl: nap2Insights,
          plannedDuration: nap2PlannedLen
        },
        {
          num: 3,
          startEl: actualNap3Start,
          endEl: actualNap3End,
          rowEl: actualNap3Row,
          insightsEl: nap3Insights,
          plannedDuration: nap3PlannedLen
        }
      ];

      let previousNapEnd = wakeMins;
      let totalActualNapTime = 0;
      let napCountWithData = 0;
      let overallInsightsText = [];

      naps.forEach((nap) => {
        const startTime = nap.startEl.value;
        const endTime = nap.endEl.value;

        // Update input styling
        if (startTime) {
          nap.startEl.classList.add('has-value');
        } else {
          nap.startEl.classList.remove('has-value');
        }
        if (endTime) {
          nap.endEl.classList.add('has-value');
        } else {
          nap.endEl.classList.remove('has-value');
        }

        // If both times are entered, calculate insights
        if (startTime && endTime) {
          const startMins = toMinutes(startTime);
          const endMins = toMinutes(endTime);

          if (startMins !== null && endMins !== null) {
            napCountWithData++;

            // Calculate nap duration
            let duration = endMins - startMins;
            if (duration < 0) duration += 24 * 60; // Handle next-day wrap

            // Calculate wake window (time from previous event to this nap start)
            let wakeWindow = startMins - previousNapEnd;
            if (wakeWindow < 0) wakeWindow += 24 * 60;

            // Compare to planned duration
            const durationDiff = duration - nap.plannedDuration;
            const durationDiffStr = durationDiff > 0 ? `+${durationDiff}` : `${durationDiff}`;

            // Build insights HTML
            let insightsHTML = `
              <div class="insight-row">
                <span class="insight-label">Duration:</span>
                <span class="insight-value">${formatDuration(duration)}</span>
              </div>
              <div class="insight-row">
                <span class="insight-label">Wake window before:</span>
                <span class="insight-value">${formatDuration(wakeWindow)}</span>
              </div>
            `;

            if (nap.plannedDuration > 0) {
              const diffClass = durationDiff > 0 ? 'positive' : (durationDiff < 0 ? 'negative' : '');
              insightsHTML += `
                <div class="insight-row">
                  <span class="insight-label">vs. Planned:</span>
                  <span class="insight-value ${diffClass}">${durationDiffStr} min</span>
                </div>
              `;
            }

            nap.insightsEl.innerHTML = insightsHTML;
            nap.insightsEl.classList.add('visible');
            nap.rowEl.classList.add('has-data');

            totalActualNapTime += duration;
            previousNapEnd = endMins;
          } else {
            nap.insightsEl.classList.remove('visible');
            nap.rowEl.classList.remove('has-data');
          }
        } else {
          nap.insightsEl.classList.remove('visible');
          nap.rowEl.classList.remove('has-data');
        }
      });

      // Update overall insights
      if (napCountWithData > 0) {
        const totalPlanned = nap1PlannedLen + nap2PlannedLen + (napCountWithData >= 3 ? nap3PlannedLen : 0);
        const totalDiff = totalActualNapTime - totalPlanned;
        const totalDiffStr = totalDiff > 0 ? `+${totalDiff}` : `${totalDiff}`;

        overallInsightsText.push(`<strong>Summary:</strong> ${napCountWithData} nap${napCountWithData > 1 ? 's' : ''} tracked`);
        overallInsightsText.push(`Total daytime sleep: ${formatDuration(totalActualNapTime)}`);
        if (totalPlanned > 0) {
          overallInsightsText.push(`Difference from plan: ${totalDiffStr} min`);
        }

        overallInsights.innerHTML = overallInsightsText.join(' â€¢ ');
        overallInsights.classList.add('visible');
      } else {
        overallInsights.classList.remove('visible');
      }

      // Update visibility of nap 3 row based on schedule
      updateActualNap3Visibility();

      // Update button state
      updateActualNapsButton();
    }

    function updateActualNap3Visibility() {
      const preferThree = useThreeNapsInput.checked;
      actualNap3Row.style.display = preferThree ? "block" : "none";
    }

    function updateNap3Visibility(actualNapCount) {
      const preferThree = useThreeNapsInput.checked;
      const showThree = (actualNapCount || (preferThree ? 3 : 2)) === 3;
      nap3Row.style.display = showThree ? "grid" : "none";
      updateActualNap3Visibility();
    }

    function applyDefaults(forceThreeNaps = null) {
      wakeInput.value = "07:00";
      bedInput.value = "20:30";            // default fixed bedtime

      // If forceThreeNaps is specified, use that; otherwise keep current state
      if (forceThreeNaps !== null) {
        useThreeNapsInput.checked = forceThreeNaps;
        updateToggleSwitch(forceThreeNaps);
      }

      lastWakeInput.value = 210;           // 3h30
      minWakeInput.value = 135;            // 2h15 min
      maxWakeInput.value = 210;            // 3h30 max

      // Set nap length defaults based on number of naps
      const preferThree = useThreeNapsInput.checked;
      if (preferThree) {
        // 3 nap schedule defaults
        nap1Input.value = 30;   // 30 min
        nap2Input.value = 60;   // 1h
        nap3Input.value = 30;   // 30 min
      } else {
        // 2 nap schedule defaults
        nap1Input.value = 90;   // 1.5h
        nap2Input.value = 30;   // 30 min
        nap3Input.value = 30;   // not used for 2 naps
      }

      updateNap3Visibility(preferThree ? 3 : 2);
    }

    function initFromStorageOrDefaults() {
      const s = loadSettings();
      if (s) {
        if (s.wakeTime) wakeInput.value = s.wakeTime;
        if (s.bedTime) bedInput.value = s.bedTime;
        useThreeNapsInput.checked = !!s.preferThree;
        updateToggleSwitch(!!s.preferThree);

        lastWakeInput.value = s.lastWake || 210;
        minWakeInput.value = s.minWake || 135;
        maxWakeInput.value = s.maxWake || 210;

        // Use appropriate defaults based on saved preference
        const preferThree = !!s.preferThree;
        nap1Input.value = s.nap1 || (preferThree ? 30 : 90);
        nap2Input.value = s.nap2 || (preferThree ? 60 : 30);
        nap3Input.value = s.nap3 || 30;

        // Load constraints if present
        if (s.constraints) {
          mustBeAwakeByInput.value = s.constraints.mustBeAwakeBy || "";
          if (s.constraints.sleepWindow) {
            sleepWindowStartInput.value = s.constraints.sleepWindow.start || "";
            sleepWindowEndInput.value = s.constraints.sleepWindow.end || "";
          }
        }
      } else {
        applyDefaults(true); // Force 3 naps for new users
      }
      updateNap3Visibility();
    }

    function getActualNapTimes() {
      // Get actual nap times if they exist
      const actuals = [];

      if (actualNap1Start.value && actualNap1End.value) {
        actuals.push({
          napNum: 1,
          start: toMinutes(actualNap1Start.value),
          end: toMinutes(actualNap1End.value)
        });
      }

      if (actualNap2Start.value && actualNap2End.value) {
        actuals.push({
          napNum: 2,
          start: toMinutes(actualNap2Start.value),
          end: toMinutes(actualNap2End.value)
        });
      }

      if (actualNap3Start.value && actualNap3End.value) {
        actuals.push({
          napNum: 3,
          start: toMinutes(actualNap3Start.value),
          end: toMinutes(actualNap3End.value)
        });
      }

      return actuals;
    }

    function tryBuildScheduleWithActuals(napCount, params, actualNaps) {
      const { wakeMins, bedMins, lastWake, minWake, maxWake, napLengths } = params;

      // Build schedule using actual nap times where available
      const items = [];
      const wakeWindowDurations = [];
      let totalNapTime = 0;

      items.push({
        label: "Wake-up",
        timeRange: fromMinutes(wakeMins),
        badge: "Start of day",
        badgeClass: "wake"
      });

      let cursor = wakeMins;

      // Process each nap
      for (let i = 0; i < napCount; i++) {
        const napNum = i + 1;
        const actualNap = actualNaps.find(a => a.napNum === napNum);

        if (actualNap) {
          // Use actual nap time
          const napStart = actualNap.start;
          const napEnd = actualNap.end;
          const napDuration = napEnd - napStart;
          const wakeWindow = napStart - cursor;

          items.push({
            label: `Nap ${napNum}`,
            timeRange: `${fromMinutes(napStart)} â€“ ${fromMinutes(napEnd)}`,
            extra: `${napDuration} min`,
            badge: "Actual",
            badgeClass: "actual",
            wakeWindow: wakeWindow,
            isActual: true
          });

          totalNapTime += napDuration;
          wakeWindowDurations.push(wakeWindow);
          cursor = napEnd;
        } else {
          // Calculate planned nap time for remaining naps
          // This is a simplified approach - we'll fit it in the remaining time
          const remainingNaps = napCount - i;
          const remainingTime = bedMins - cursor;

          // Calculate how much time we need for remaining naps and wake windows
          let remainingNapTime = 0;
          for (let j = i; j < napCount; j++) {
            remainingNapTime += napLengths[j];
          }

          // Last wake window is fixed
          const isLastNap = (i === napCount - 1);
          const targetWakeAfter = isLastNap ? lastWake : minWake;

          const availableForWakeWindows = remainingTime - remainingNapTime;
          const wakeWindowsNeeded = remainingNaps; // one before each nap

          // Distribute wake windows
          let wakeWindow;
          if (isLastNap) {
            wakeWindow = lastWake;
          } else {
            wakeWindow = Math.max(minWake, Math.min(maxWake, availableForWakeWindows / wakeWindowsNeeded));
          }

          const napStart = cursor + wakeWindow;
          const napLen = napLengths[i];
          const napEnd = napStart + napLen;

          items.push({
            label: `Nap ${napNum}`,
            timeRange: `${fromMinutes(napStart)} â€“ ${fromMinutes(napEnd)}`,
            extra: `${napLen} min`,
            badge: "Planned",
            badgeClass: "planned",
            wakeWindow: wakeWindow,
            isActual: false
          });

          totalNapTime += napLen;
          wakeWindowDurations.push(wakeWindow);
          cursor = napEnd;
        }
      }

      // Final wake window to bedtime
      const finalWakeWindow = bedMins - cursor;
      wakeWindowDurations.push(finalWakeWindow);

      items.push({
        label: "Bedtime",
        timeRange: fromMinutes(bedMins),
        badge: "End of day",
        badgeClass: "bed",
        wakeWindow: finalWakeWindow
      });

      return {
        ok: true,
        items,
        wakeWindowsAll: wakeWindowDurations,
        wakeWindowDurations,
        totalNapTime,
        bedtimeMins: bedMins,
        napCountUsed: napCount,
        hasActuals: true
      };
    }

    function tryBuildSchedule(napCount, params) {
      const {
        wakeMins,
        bedMins,
        lastWake,
        minWake,
        maxWake,
        napLengths
      } = params;

      const actualNaps = getActualNapTimes();

      // If we have actual nap times, use a different scheduling approach
      if (actualNaps.length > 0) {
        return tryBuildScheduleWithActuals(napCount, params, actualNaps);
      }

      const totalNapTime = napLengths.slice(0, napCount).reduce((a, b) => a + b, 0);
      const totalDay = bedMins - wakeMins;

      if (totalDay <= 0) {
        return { ok: false, reason: "Bedtime must be after wake time (same or next day)." };
      }

      const totalAwake = totalDay - totalNapTime;
      const remainingBeforeLast = totalAwake - lastWake;

      if (remainingBeforeLast < 0) {
        return { ok: false, reason: "Not enough time for naps + last wake window before bed." };
      }

      const nWindowsBeforeLast = napCount; // one before each nap
      if (nWindowsBeforeLast === 0) {
        return { ok: false, reason: "Need at least one nap." };
      }

      const minTotal = minWake * nWindowsBeforeLast;
      const maxTotal = maxWake * nWindowsBeforeLast;

      if (remainingBeforeLast < minTotal || remainingBeforeLast > maxTotal) {
        return {
          ok: false,
          reason: "Awake windows would have to go outside the min/max limits."
        };
      }

      // Build wake windows before naps, starting at min and adding to later windows first
      const wakeWindowsBefore = new Array(nWindowsBeforeLast).fill(minWake);
      let leftover = remainingBeforeLast - minTotal;

      for (let i = nWindowsBeforeLast - 1; i >= 0 && leftover > 0; i--) {
        const canAdd = maxWake - wakeWindowsBefore[i];
        const add = Math.min(canAdd, leftover);
        wakeWindowsBefore[i] += add;
        leftover -= add;
      }

      const wakeWindowsAll = [...wakeWindowsBefore, lastWake];

      // Build schedule items
      const items = [];
      const wakeWindowDurations = [];

      items.push({
        label: "Wake-up",
        timeRange: fromMinutes(wakeMins),
        badge: "Start of day",
        badgeClass: "wake"
      });

      let cursor = wakeMins;

      for (let i = 0; i < napCount; i++) {
        const ww = wakeWindowsBefore[i] || 0;
        const napLen = napLengths[i];

        cursor += ww;
        const napStart = cursor;
        const napEnd = napStart + napLen;
        wakeWindowDurations.push(ww);

        items.push({
          label: `Nap ${i + 1}`,
          timeRange: `${fromMinutes(napStart)} â€“ ${fromMinutes(napEnd)}`,
          extra: `${napLen} min`,
          badge: "Nap",
          badgeClass: "",
          wakeWindow: ww  // Add wake window before this nap
        });

        cursor = napEnd;
      }

      // Final wake window to fixed bedtime
      const finalWakeWindow = lastWake;
      cursor += finalWakeWindow;
      wakeWindowDurations.push(finalWakeWindow);

      const resultingBedtimeMins = cursor; // should equal bedMins

      items.push({
        label: "Bedtime",
        timeRange: fromMinutes(resultingBedtimeMins),
        badge: "End of day",
        badgeClass: "bed",
        wakeWindow: finalWakeWindow  // Add wake window before bedtime
      });

      return {
        ok: true,
        items,
        wakeWindowsAll,
        wakeWindowDurations,
        totalNapTime,
        bedtimeMins: resultingBedtimeMins,
        napCountUsed: napCount
      };
    }

    function generateNapCombinations(originalNapLengths, napCount, minNap, maxAdjust) {
      // Generate smart nap length combinations to try
      // Start with minimal changes, then progressively try more adjustments

      const combinations = [];

      // 1. Try original lengths first
      combinations.push([...originalNapLengths]);

      // 2. Try single nap adjustments (Â±5, Â±10, Â±15, Â±20, Â±25, Â±30 min)
      for (let i = 0; i < napCount; i++) {
        for (let adj = -maxAdjust; adj <= maxAdjust; adj += 5) {
          if (adj === 0) continue;
          const newLength = originalNapLengths[i] + adj;
          if (newLength >= minNap) {
            const combo = [...originalNapLengths];
            combo[i] = newLength;
            combinations.push(combo);
          }
        }
      }

      // 3. Try pairwise adjustments (shift time between two naps)
      for (let i = 0; i < napCount; i++) {
        for (let j = i + 1; j < napCount; j++) {
          for (let transfer = 5; transfer <= 30; transfer += 5) {
            // Transfer from i to j
            if (originalNapLengths[i] - transfer >= minNap) {
              const combo = [...originalNapLengths];
              combo[i] = originalNapLengths[i] - transfer;
              combo[j] = originalNapLengths[j] + transfer;
              combinations.push(combo);
            }
            // Transfer from j to i
            if (originalNapLengths[j] - transfer >= minNap) {
              const combo = [...originalNapLengths];
              combo[j] = originalNapLengths[j] - transfer;
              combo[i] = originalNapLengths[i] + transfer;
              combinations.push(combo);
            }
          }
        }
      }

      return combinations;
    }

    function adjustScheduleForConstraints(params) {
      const { wakeMins, bedMins, lastWake, minWake, maxWake, napLengths, napCount } = params;

      // Get constraint values
      const mustBeAwakeByStr = mustBeAwakeByInput.value;
      const sleepWindowStartStr = sleepWindowStartInput.value;
      const sleepWindowEndStr = sleepWindowEndInput.value;

      // If no constraints at all, return null (no adjustment needed)
      if (!mustBeAwakeByStr && !(sleepWindowStartStr && sleepWindowEndStr)) {
        return null;
      }

      // Parse and normalize "must be awake by" constraint if present
      let mustBeAwakeBy = null;
      if (mustBeAwakeByStr) {
        mustBeAwakeBy = toMinutes(mustBeAwakeByStr);
        if (mustBeAwakeBy !== null) {
          while (mustBeAwakeBy < wakeMins - 12 * 60) mustBeAwakeBy += 24 * 60;
          while (mustBeAwakeBy > wakeMins + 12 * 60) mustBeAwakeBy -= 24 * 60;
        }
      }

      // Parse and normalize "must be asleep during" constraint if present
      let sleepStart = null;
      let sleepEnd = null;
      if (sleepWindowStartStr && sleepWindowEndStr) {
        sleepStart = toMinutes(sleepWindowStartStr);
        sleepEnd = toMinutes(sleepWindowEndStr);
        if (sleepStart !== null && sleepEnd !== null) {
          while (sleepStart < wakeMins - 12 * 60) sleepStart += 24 * 60;
          while (sleepStart > wakeMins + 12 * 60) sleepStart -= 24 * 60;
          while (sleepEnd < wakeMins - 12 * 60) sleepEnd += 24 * 60;
          while (sleepEnd > wakeMins + 12 * 60) sleepEnd -= 24 * 60;
          if (sleepEnd <= sleepStart) {
            sleepEnd += 24 * 60;
          }
        }
      }

      // Build the schedule and check constraints
      let scheduleResult = tryBuildSchedule(napCount, params);
      if (!scheduleResult.ok) {
        return null; // Can't even build basic schedule
      }

      // Check if constraints are already satisfied
      const violations = validateConstraints(scheduleResult, wakeMins, bedMins);
      if (violations.length === 0) {
        return null; // Already satisfied, no adjustment needed
      }

      // UNIFIED LINEAR PROGRAMMING APPROACH
      // Try adjusting bedtime + nap lengths simultaneously to satisfy constraints
      // Wake windows are distributed automatically by tryBuildSchedule with increasing pattern

      const MIN_NAP = 30;
      const MAX_NAP_ADJUST = 30; // Max adjustment per nap (+ or -)

      // Bedtime adjustments to try (in order of preference)
      const bedtimeAdjustments = [
        0,    // Try with original bedtime first
        -15, -30, -45,  // Earlier bedtimes
        15, 30          // Later bedtimes
      ];

      // Try each bedtime adjustment with nap length variations
      for (const bedAdj of bedtimeAdjustments) {
        const adjustedBedMins = bedMins + bedAdj;

        // Generate nap length combinations to try
        const napCombinations = generateNapCombinations(napLengths, napCount, MIN_NAP, MAX_NAP_ADJUST);

        for (const testNapLengths of napCombinations) {
          const testParams = {
            ...params,
            bedMins: adjustedBedMins,
            napLengths: testNapLengths
          };

          const testSchedule = tryBuildSchedule(napCount, testParams);

          if (testSchedule.ok) {
            const testViolations = validateConstraints(testSchedule, wakeMins, adjustedBedMins);
            if (testViolations.length === 0) {
              // Found a solution!
              const changes = [];
              if (bedAdj !== 0) {
                changes.push(`bedtime ${bedAdj > 0 ? 'later' : 'earlier'} by ${Math.abs(bedAdj)} min to ${fromMinutes(adjustedBedMins)}`);
              }

              const napChanges = [];
              for (let i = 0; i < napCount; i++) {
                const diff = testNapLengths[i] - napLengths[i];
                if (diff !== 0) {
                  napChanges.push(`Nap ${i + 1} ${diff > 0 ? '+' : ''}${diff} min`);
                }
              }
              if (napChanges.length > 0) {
                changes.push(`adjusted naps: ${napChanges.join(', ')}`);
              }

              return {
                schedule: testSchedule,
                strategy: 'unified-adjustment',
                changes: { bedMins: adjustedBedMins, napLengths: testNapLengths },
                message: `Adjusted schedule: ${changes.join(', ')}`,
                napChanges: testNapLengths
              };
            }
          }
        }
      }

      // Strategy 2: Try alternative nap count (2 vs 3)
      const alternateNapCount = napCount === 2 ? 3 : 2;
      const alternateNapLengths = alternateNapCount === 3 ? [30, 60, 30] : [90, 30, 30];
      const testParams4 = { ...params, napCount: alternateNapCount, napLengths: alternateNapLengths };
      const testSchedule4 = tryBuildSchedule(alternateNapCount, testParams4);

      if (testSchedule4.ok) {
        const testViolations4 = validateConstraints(testSchedule4, wakeMins, bedMins);
        if (testViolations4.length === 0) {
          return {
            schedule: testSchedule4,
            strategy: 'nap-count',
            changes: { napCount: alternateNapCount, napLengths: alternateNapLengths },
            message: `Switched to ${alternateNapCount}-nap schedule to meet constraint`,
            napChanges: alternateNapLengths
          };
        }
      }

      return null; // Couldn't satisfy constraint with any strategy
    }

    function validateConstraints(scheduleResult, wakeMins, bedMins) {
      const violations = [];

      // Get constraint values
      const mustBeAwakeByStr = mustBeAwakeByInput.value;
      const sleepWindowStartStr = sleepWindowStartInput.value;
      const sleepWindowEndStr = sleepWindowEndInput.value;

      // Check "must be awake by" constraint
      if (mustBeAwakeByStr) {
        let mustBeAwakeBy = toMinutes(mustBeAwakeByStr);
        if (mustBeAwakeBy !== null) {
          // Normalize to same day cycle as schedule
          while (mustBeAwakeBy < wakeMins - 12 * 60) mustBeAwakeBy += 24 * 60;
          while (mustBeAwakeBy > wakeMins + 12 * 60) mustBeAwakeBy -= 24 * 60;

          // Check if any nap overlaps with the "must be awake by" time
          const naps = scheduleResult.items.filter(item => item.label.startsWith("Nap"));
          for (const nap of naps) {
            const [startStr, endStr] = nap.timeRange.split(" â€“ ");
            let napStart = toMinutes(startStr);
            let napEnd = toMinutes(endStr);

            // Normalize to same day cycle
            while (napStart < wakeMins - 12 * 60) napStart += 24 * 60;
            while (napStart > wakeMins + 12 * 60) napStart -= 24 * 60;
            while (napEnd < wakeMins - 12 * 60) napEnd += 24 * 60;
            while (napEnd > wakeMins + 12 * 60) napEnd -= 24 * 60;

            // Check if the constraint time falls during this nap
            if (mustBeAwakeBy >= napStart && mustBeAwakeBy < napEnd) {
              violations.push({
                type: 'awake-by',
                message: `${nap.label} runs from ${startStr} to ${endStr}, but baby needs to be awake by ${mustBeAwakeByStr}.`,
                suggestion: `Try: (1) Start ${nap.label} earlier, (2) Shorten ${nap.label}, or (3) Move wake time earlier to shift the schedule.`
              });
              break; // Only report the first conflicting nap
            }
          }
        }
      }

      // Check "must be asleep during" constraint
      if (sleepWindowStartStr && sleepWindowEndStr) {
        let sleepStart = toMinutes(sleepWindowStartStr);
        let sleepEnd = toMinutes(sleepWindowEndStr);

        if (sleepStart !== null && sleepEnd !== null) {
          // Normalize to same day cycle
          while (sleepStart < wakeMins - 12 * 60) sleepStart += 24 * 60;
          while (sleepStart > wakeMins + 12 * 60) sleepStart -= 24 * 60;
          while (sleepEnd < wakeMins - 12 * 60) sleepEnd += 24 * 60;
          while (sleepEnd > wakeMins + 12 * 60) sleepEnd -= 24 * 60;

          // Handle wrap-around if end < start
          if (sleepEnd <= sleepStart) {
            sleepEnd += 24 * 60;
          }

          // Check if any part of the sleep window overlaps with awake time
          const naps = scheduleResult.items.filter(item => item.label.startsWith("Nap"));
          let isAsleepDuringWindow = false;

          for (const nap of naps) {
            const [startStr, endStr] = nap.timeRange.split(" â€“ ");
            let napStart = toMinutes(startStr);
            let napEnd = toMinutes(endStr);

            // Normalize
            while (napStart < wakeMins - 12 * 60) napStart += 24 * 60;
            while (napStart > wakeMins + 12 * 60) napStart -= 24 * 60;
            while (napEnd < wakeMins - 12 * 60) napEnd += 24 * 60;
            while (napEnd > wakeMins + 12 * 60) napEnd -= 24 * 60;

            // Check if nap covers the entire required sleep window
            if (napStart <= sleepStart && napEnd >= sleepEnd) {
              isAsleepDuringWindow = true;
              break;
            }
          }

          if (!isAsleepDuringWindow) {
            violations.push({
              type: 'sleep-window',
              message: `Baby needs to be asleep from ${sleepWindowStartStr} to ${sleepWindowEndStr}, but no nap fully covers this window.`,
              suggestion: `Try: (1) Adjust nap timing to cover this window, (2) Extend a nap, or (3) Adjust wake time.`
            });
          }
        }
      }

      return violations;
    }

    function recomputeSchedule() {
      if (isRecomputing) return; // Prevent recursive calls
      isRecomputing = true;

      try {
        saveSettings();

        scheduleList.innerHTML = "";
        wakeWindowsText.textContent = "";
        summaryLabel.textContent = "";
        bedtimeNote.textContent = "";
        modeNote.textContent = "";
        warningBox.style.display = "none";
        // Reset warning box styles
        warningBox.style.background = "";
        warningBox.style.borderColor = "";
        warningBox.style.color = "";
        // Clear preference mismatch indicator
        napToggleSwitch.classList.remove('preference-mismatch');

        const wakeMins = toMinutes(wakeInput.value);
        let bedMins = toMinutes(bedInput.value);

        if (wakeMins == null || bedMins == null) {
          warningBox.style.display = "block";
          warningBox.textContent = "Please set both wake-up time and bedtime.";
          return;
        }

        // Allow bedtime to roll onto next day if it's earlier than wake
        if (bedMins <= wakeMins) {
          bedMins += 24 * 60;
        }

        const minWake = Number(minWakeInput.value);
        const maxWake = Number(maxWakeInput.value);
        const lastWake = Number(lastWakeInput.value);

        // Validate all wake window inputs
        if (!minWake || minWake <= 0) {
          warningBox.style.display = "block";
          warningBox.textContent = "Min wake window must be greater than 0.";
          return;
        }

        if (!maxWake || maxWake <= 0) {
          warningBox.style.display = "block";
          warningBox.textContent = "Max wake window must be greater than 0.";
          return;
        }

        if (maxWake < minWake) {
          warningBox.style.display = "block";
          warningBox.textContent = "Max wake window must be greater than or equal to min wake window.";
          return;
        }

        if (!lastWake || lastWake <= 0) {
          warningBox.style.display = "block";
          warningBox.textContent = "Last wake window must be greater than 0.";
          return;
        }

        if (lastWake < minWake || lastWake > maxWake) {
          warningBox.style.display = "block";
          warningBox.textContent = `Last wake window must be between ${minWake} and ${maxWake} minutes.`;
          return;
        }

        const nap1Len = Number(nap1Input.value) || 0;
        const nap2Len = Number(nap2Input.value) || 0;
        const nap3Len = Number(nap3Input.value) || 0;
        const napLengths = [nap1Len, nap2Len, nap3Len];

        if (nap1Len <= 0 || nap2Len <= 0) {
          warningBox.style.display = "block";
          warningBox.textContent = "Nap 1 and Nap 2 lengths should be greater than 0 minutes.";
          return;
        }

        const preferThree = !!useThreeNapsInput.checked;
        let requestedNapCount = preferThree ? 3 : 2;

        let scheduleResult = null;
        let autoDowngraded = false;
        let autoUpgraded = false;
        let threeNapFailReason = null;
        let twoNapFailReason = null;

        const params = { wakeMins, bedMins, lastWake, minWake, maxWake, napLengths };

        // Try requested nap count, with auto-downgrade from 3 to 2 if needed
        if (requestedNapCount === 3) {
          scheduleResult = tryBuildSchedule(3, params);
          if (!scheduleResult.ok) {
            threeNapFailReason = scheduleResult.reason;
            // Auto-downgrade to 2 naps with appropriate defaults
            nap1Input.value = 90;
            nap2Input.value = 30;
            const newNapLengths = [90, 30, Number(nap3Input.value) || 30];
            const newParams = { wakeMins, bedMins, lastWake, minWake, maxWake, napLengths: newNapLengths };
            scheduleResult = tryBuildSchedule(2, newParams);
            if (scheduleResult.ok) {
              autoDowngraded = true;
              requestedNapCount = 2;
              // Don't change checkbox - keep user's preference
              napToggleSwitch.classList.add('preference-mismatch');
            }
          }
        } else {
          scheduleResult = tryBuildSchedule(2, params);
          if (!scheduleResult.ok) {
            twoNapFailReason = scheduleResult.reason;
            // Auto-upgrade to 3 naps with appropriate defaults
            nap1Input.value = 30;
            nap2Input.value = 60;
            nap3Input.value = 30;
            const newNapLengths = [30, 60, 30];
            const newParams = { wakeMins, bedMins, lastWake, minWake, maxWake, napLengths: newNapLengths };
            scheduleResult = tryBuildSchedule(3, newParams);
            if (scheduleResult.ok) {
              autoUpgraded = true;
              requestedNapCount = 3;
              // Don't change checkbox - keep user's preference
              napToggleSwitch.classList.add('preference-mismatch');
            }
          }
        }

        if (!scheduleResult || !scheduleResult.ok) {
          warningBox.style.display = "block";
          let errorMsg = "Could not create a valid schedule. ";

          if (scheduleResult && scheduleResult.reason) {
            errorMsg += scheduleResult.reason + " ";
          }

          // Provide specific guidance based on the error
          if (scheduleResult && scheduleResult.reason && scheduleResult.reason.includes("outside the min/max limits")) {
            errorMsg += "Try: (1) Increase max wake window, (2) Decrease min wake window, or (3) Reduce nap lengths.";
          } else if (scheduleResult && scheduleResult.reason && scheduleResult.reason.includes("Not enough time")) {
            errorMsg += "Try: (1) Reduce total nap time, (2) Move bedtime later, or (3) Reduce last wake window.";
          } else {
            errorMsg += "Try adjusting nap lengths, wake windows, or wake/bed times.";
          }

          if (threeNapFailReason) {
            errorMsg += " (Note: 3 naps also failed - " + threeNapFailReason + ")";
          }

          if (twoNapFailReason) {
            errorMsg += " (Note: 2 naps also failed - " + twoNapFailReason + ")";
          }

          warningBox.textContent = errorMsg;
          updateNap3Visibility(requestedNapCount);
          return;
        }

        // Try to adjust schedule for constraints
        let constraintAdjustmentInfo = null;
        let adjustedBedMins = bedMins; // Track adjusted bedtime for validation
        const adjustment = adjustScheduleForConstraints({ wakeMins, bedMins, lastWake, minWake, maxWake, napLengths, napCount: scheduleResult.napCountUsed });

        if (adjustment) {
          // Use the adjusted schedule
          scheduleResult = adjustment.schedule;
          constraintAdjustmentInfo = {
            strategy: adjustment.strategy,
            message: adjustment.message
          };

          // Track adjusted bedtime for validation (but don't modify input)
          if (adjustment.strategy === 'bedtime') {
            adjustedBedMins = adjustment.changes.bedMins;
          }

          // DO NOT modify input values - user's preferences should remain unchanged
          // The adjustment only affects the displayed schedule, not their settings
        }

        const {
          items,
          wakeWindowDurations,
          totalNapTime,
          bedtimeMins,
          napCountUsed
        } = scheduleResult;

        updateNap3Visibility(napCountUsed);

        // Validate constraints (use adjusted bedtime if it was changed)
        const constraintViolations = validateConstraints(scheduleResult, wakeMins, adjustedBedMins);

        const scheduleTextLines = [];
        scheduleList.innerHTML = "";

        items.forEach((item) => {
          const li = document.createElement("li");
          const left = document.createElement("div");
          const right = document.createElement("div");

          left.innerHTML = `<strong>${item.label}</strong><br/><span class="time">${item.timeRange}</span>`;
          if (item.extra) {
            left.innerHTML += `<br/><span class="subtext">${item.extra}</span>`;
          }
          // Add wake window duration if present
          if (item.wakeWindow) {
            left.innerHTML += `<br/><span class="subtext" style="color: #facc15;">â†‘ ${formatDuration(item.wakeWindow)} awake</span>`;
          }

          if (item.badge) {
            right.innerHTML = `<span class="badge ${item.badgeClass || ""}">${item.badge}</span>`;
          }

          li.appendChild(left);
          li.appendChild(right);
          scheduleList.appendChild(li);

          if (item.label === "Wake-up" || item.label === "Bedtime") {
            scheduleTextLines.push(`${item.label}: ${item.timeRange}`);
          } else {
            scheduleTextLines.push(
                    `${item.label}: ${item.timeRange} (${item.extra || ""})`.replace(/\s+\(\)/, "")
            );
          }
        });

        // Wake window summary line
        const wwStrings = wakeWindowDurations.map((mins, idx) => {
          const label =
                  idx === 0
                          ? "Before nap 1"
                          : idx === wakeWindowDurations.length - 1
                                  ? "Before bed"
                                  : `Between naps ${idx} & ${idx + 1}`;
          return `${label}: ${formatDuration(mins)}`;
        });
        wakeWindowsText.textContent = wwStrings.join("  â€¢  ");

        // Bedtime note (should match target)
        const totalNapHours = (totalNapTime / 60).toFixed(2);
        summaryLabel.textContent = `${napCountUsed} naps â€¢ ${totalNapHours}h total daytime sleep`;

        const originalTargetBed = toMinutes(bedInput.value);
        if (originalTargetBed != null) {
          // normalise original target to nearest instance to resulting bedtime
          let target = originalTargetBed;
          while (target < bedtimeMins - 12 * 60) target += 24 * 60;
          while (target > bedtimeMins + 12 * 60) target -= 24 * 60;
          const diff = bedtimeMins - target;
          const absDiff = Math.abs(diff);
          const sign = diff === 0 ? "" : diff > 0 ? "+" : "-";
          const diffStr = formatDuration(absDiff);
          bedtimeNote.textContent = `Bedtime is fixed at ${fromMinutes(
                  originalTargetBed
          )}. Schedule lands exactly there (${sign}${diffStr} difference after day normalisation).`;
        } else {
          bedtimeNote.textContent = `Resulting bedtime: ${fromMinutes(bedtimeMins)}`;
        }

        // Check if we're using actual nap times
        const actualNaps = getActualNapTimes();
        let modeMessages = [];

        if (actualNaps.length > 0) {
          modeMessages.push(`ðŸ“Š Using ${actualNaps.length} actual nap time${actualNaps.length > 1 ? 's' : ''}`);
        }

        if (autoDowngraded) {
          modeMessages.push("âš ï¸ Automatically switched to 2 naps (3 naps couldn't fit: " + threeNapFailReason + ")");
        } else if (autoUpgraded) {
          modeMessages.push("âœ“ Automatically switched to 3 naps (2 naps couldn't fit: " + twoNapFailReason + ")");
        }

        modeNote.textContent = modeMessages.join(" â€¢ ");

        // Display constraint violations if any, or success message if constraints are set and met
        const hasConstraints = !!(mustBeAwakeByInput.value || (sleepWindowStartInput.value && sleepWindowEndInput.value));

        // Show adjustment info if schedule was modified
        if (constraintAdjustmentInfo) {
          modeNote.textContent = (modeNote.textContent ? modeNote.textContent + " " : "") +
            `âœ“ ${constraintAdjustmentInfo.message}`;
        }

        if (constraintViolations.length > 0) {
          warningBox.style.display = "block";
          warningBox.style.background = "rgba(248, 113, 113, 0.12)";
          warningBox.style.borderColor = "rgba(248, 113, 113, 0.35)";
          warningBox.style.color = "#fecaca";
          let constraintMsg = "âš ï¸ Schedule constraints not met:\n\n";
          constraintViolations.forEach((v, idx) => {
            constraintMsg += `${idx + 1}. ${v.message}\n   ${v.suggestion}\n\n`;
          });
          warningBox.innerHTML = constraintMsg.replace(/\n/g, '<br/>');
        } else if (hasConstraints) {
          warningBox.style.display = "block";
          warningBox.style.background = "rgba(34, 197, 94, 0.12)";
          warningBox.style.borderColor = "rgba(34, 197, 94, 0.35)";
          warningBox.style.color = "#bbf7d0";
          warningBox.innerHTML = "âœ“ All schedule constraints are satisfied!";
        }

        copyBtn.dataset.scheduleText = scheduleTextLines.join("\n");
      } finally {
        isRecomputing = false; // Always reset the flag
      }
    }

    resetBtn.addEventListener("click", () => {
      applyDefaults();
      // Clear constraints
      mustBeAwakeByInput.value = "";
      sleepWindowStartInput.value = "";
      sleepWindowEndInput.value = "";
      // Clear actual naps
      clearAllActualNaps();
      updateConstraintsButton();
      recomputeSchedule();
    });

    copyBtn.addEventListener("click", async () => {
      const text = copyBtn.dataset.scheduleText || "";
      if (!text) return;
      try {
        await navigator.clipboard.writeText(text);
        const prev = copyBtn.textContent;
        copyBtn.textContent = "Copied!";
        setTimeout(() => (copyBtn.textContent = prev), 900);
      } catch {
        const prev = copyBtn.textContent;
        copyBtn.textContent = "Copy failed";
        setTimeout(() => (copyBtn.textContent = prev), 900);
      }
    });

    // Helper function to update toggle switch visual state
    function updateToggleSwitch(preferThree) {
      const options = napToggleSwitch.querySelectorAll('.nap-toggle-option');
      if (preferThree) {
        napToggleSwitch.classList.add('three-naps');
        options[0].classList.remove('active');
        options[1].classList.add('active');
      } else {
        napToggleSwitch.classList.remove('three-naps');
        options[0].classList.add('active');
        options[1].classList.remove('active');
      }
    }

    // Toggle switch click handler
    napToggleSwitch.addEventListener("click", (e) => {
      const option = e.target.closest('.nap-toggle-option');
      if (!option) return;

      const preferThree = option.dataset.value === "3";
      useThreeNapsInput.checked = preferThree;
      updateToggleSwitch(preferThree);

      // Trigger the checkbox change event to handle nap defaults
      useThreeNapsInput.dispatchEvent(new Event('change'));
    });

    // Special handler for prefer 3 naps checkbox - update defaults when toggled
    useThreeNapsInput.addEventListener("change", () => {
      const preferThree = useThreeNapsInput.checked;
      if (preferThree) {
        // Switching to 3 naps - apply 3-nap defaults
        nap1Input.value = 30;
        nap2Input.value = 60;
        nap3Input.value = 30;
      } else {
        // Switching to 2 naps - apply 2-nap defaults
        nap1Input.value = 90;
        nap2Input.value = 30;
      }
      recomputeSchedule();
    });

    [
      wakeInput,
      bedInput,
      lastWakeInput,
      minWakeInput,
      maxWakeInput,
      nap1Input,
      nap2Input,
      nap3Input
    ].forEach((el) => {
      el.addEventListener("input", recomputeSchedule);
    });

    // Actual naps tracking event listeners
    [
      actualNap1Start,
      actualNap1End,
      actualNap2Start,
      actualNap2End,
      actualNap3Start,
      actualNap3End
    ].forEach((el) => {
      el.addEventListener("input", () => {
        saveActualNaps();
        updateActualNapsInsights();
      });
    });

    // Clear individual nap buttons
    document.querySelectorAll('.clear-nap-btn').forEach((btn) => {
      btn.addEventListener('click', () => {
        const napNum = parseInt(btn.dataset.nap);
        clearSingleNap(napNum);
      });
    });

    // Clear all actual naps button
    clearAllActualsBtn.addEventListener('click', () => {
      clearAllActualNaps();
    });

    // Apply actual durations to planned schedule
    useActualDurationsBtn.addEventListener('click', () => {
      let updated = false;

      // Nap 1
      if (actualNap1Start.value && actualNap1End.value) {
        const start = toMinutes(actualNap1Start.value);
        const end = toMinutes(actualNap1End.value);
        if (start !== null && end !== null) {
          let duration = end - start;
          if (duration < 0) duration += 24 * 60;
          nap1Input.value = duration;
          updated = true;
        }
      }

      // Nap 2
      if (actualNap2Start.value && actualNap2End.value) {
        const start = toMinutes(actualNap2Start.value);
        const end = toMinutes(actualNap2End.value);
        if (start !== null && end !== null) {
          let duration = end - start;
          if (duration < 0) duration += 24 * 60;
          nap2Input.value = duration;
          updated = true;
        }
      }

      // Nap 3
      if (actualNap3Start.value && actualNap3End.value) {
        const start = toMinutes(actualNap3Start.value);
        const end = toMinutes(actualNap3End.value);
        if (start !== null && end !== null) {
          let duration = end - start;
          if (duration < 0) duration += 24 * 60;
          nap3Input.value = duration;
          updated = true;
        }
      }

      if (updated) {
        recomputeSchedule();
        // Close modal and visual feedback
        closeActualNapsModal();
        const prev = useActualDurationsBtn.textContent;
        useActualDurationsBtn.textContent = "Applied!";
        setTimeout(() => (useActualDurationsBtn.textContent = prev), 1500);
      }
    });

    // Check for midnight reset on init
    checkMidnightReset();

    initFromStorageOrDefaults();
    loadActualNaps();
    updateConstraintsButton();
    updateActualNapsButton();
    updateActualNapsInsights();
    recomputeSchedule();

    // Display app version
    document.getElementById("versionDisplay").textContent = `v${APP_VERSION}`;
  })();
</script>
</body>
</html>
